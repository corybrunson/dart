% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/combinatorial.R
\name{rank_combn}
\alias{rank_combn}
\title{Rank combinations}
\usage{
rank_combn(x, n)
}
\arguments{
\item{x}{(k x m) matrix of the k-combinations to rank, or a list of combinations.}

\item{n}{choice of number system to rank against. Must be at least as large as the largest value in \code{x}.}
}
\description{
Ranks combinations lexicographically
}
\details{
This function is a ranking function which maps k-combinations to their 
position in the lexicographically ordered combinatorial number system. The combinatorial number system
of degree \code{k} is a bijection from all (\code{n} choose \code{k}) combinations to the natural numbers. 
Here, the ranks returned start from 1, and the combinations are expected to not contain 0s. 
The choice of \code{n} affects the ranking, but the ranking will always rank combinations in 
lexicographical order, e.g. \code{rank_combn(c(1,2,3)) < rank_combn(c(1,2,4)) < ...}. 
#' For example, if \code{x}  equals \code{combn(5,2)}, then \code{all(rank_combn(x) == seq_len(choose(5,2)))} 
is \code{TRUE}. \cr
\cr
In general, ranking combinations is faster than unranking them, since the computation reduces
essentially to summing up binomial coefficient. In the case where k = 2, the ranking is 
particularly efficient, since a closed-form solution is known.
}
