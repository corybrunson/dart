---
title: "2d Persistence"
output: html_notebook
---

```{r}
# X_50k <- R.matlab::readMat("~/Downloads/n50000Dct.mat")
x_15_30 <- R.matlab::readMat("~/Downloads/nk15c30Dct.mat")$nk15c30Dct
# X <- X_50k$n50000Dct
X <- x_15_30

D <- do.call(rbind, list(
	c(2 ,-1, 0,-1, 0, 0, 0, 0, 0), 
	c(-1, 3,-1, 0,-1, 0, 0, 0, 0), 
	c( 0,-1, 2, 0, 0,-1, 0, 0, 0), 
	c(-1, 0, 0, 3,-1, 0,-1, 0, 0), 
	c( 0,-1, 0,-1, 4,-1, 0,-1, 0), 
	c( 0, 0,-1, 0,-1, 3, 0, 0,-1),
	c( 0, 0, 0,-1, 0, 0, 2,-1, 0),
	c( 0, 0, 0, 0,-1, 0,-1, 3,-1),
	c( 0, 0, 0, 0, 0,-1, 0,-1, 2))
)
e1 <- (1/sqrt(6))*matrix(c(1,1,1,0,0,0,-1,-1,-1), ncol = 3)
e2 <- t(e1)
e3 <- (1/sqrt(54))*matrix(c(1,1,1,-2,-2,-2,1,1,1), ncol = 3)
e4 <- t(e3)
e5 <- (1/sqrt(8))*matrix(c(1,0,-1,0,0,0,-1,0,1), ncol = 3, byrow = TRUE)
e6 <- (1/sqrt(48))*matrix(c(1,0,-1,-2,0,2,1,0,-1), ncol = 3, byrow = TRUE)
e7 <- (1/sqrt(48))*matrix(c(1,-2,1,0,0,0,-1,2,-1), ncol = 3, byrow = TRUE)
e8 <- (1/sqrt(216))*matrix(c(1,-2,1,-2,4,-2,1,-2,1), ncol = 3, byrow = TRUE)
# e9 <- matrix(c(1,1,1,1,1,1,1,1,1), ncol = 3)
A <- do.call(cbind, lapply(1:8, function(i) eval(parse(text=sprintf("as.vector(e%d)", i)))))
# apply(A, 2, function(e){ t(matrix(as.vector(e))) %*% D %*% matrix(as.vector(e)) })
V <- t(A %*% t(X))

bin_col <- function(x, col_pal, x_rng = range(x)){
	breaks <- seq(x_rng[1], x_rng[2], length.out = length(col_pal))
	col_pal[findInterval(x = x, vec = breaks, all.inside = TRUE)]
}
normalize <- function(x){ (x - min(x))/(diff(range(x))) }

## Get landmarks 
d_left <- proxy::dist(X[,1:2], matrix(c(-1,0), ncol = 2))
lm_idx <- landmark::landmarks_maxmin(X[,1:2], num = 15, seed_index = which.min(d_left))

x_step <- diff(range(X[,1]))*0.05
y_step <- diff(range(X[,2]))*0.05
plot(X[,1:2], pch = 20, col = adjustcolor("black", alpha.f = 0.20))
for (idx in lm_idx){
	x_pt <- X[idx,1:2][1]
	y_pt <- X[idx,1:2][2]
	rasterImage(
		matrix(normalize(V[idx,]), nrow = 3, byrow = TRUE), 
		xleft = x_pt-x_step, xright = x_pt+x_step, 
		ybottom = y_pt-y_step, ytop = y_pt+y_step, 
		interpolate = FALSE
	)
}


# lm_idx <- landmark::landmarks_lastfirst(X, num = 15)

# Vd <- function(d){ (pi^(d/2))/(gamma(d/2.0 + 1)) }
# x_knn <- RANN::nn2(X, k = 15)
# knn_density <- (15/nrow(X))*(1/(Vd(8)*x_knn$nn.dists[,15]))
# N <- 25 # number of strata
# knn_levels <- seq(min(knn_density), max(knn_density), length.out = N)
# # knn_quantiles <- quantile(knn_density, probs = seq(0, 1, length.out = N))
# strata_sizes <- sapply(seq(length(knn_levels)-1L), function(i){
# 	lb <- knn_levels[i]
# 	ub <- knn_levels[i+1L]
# 	sum(knn_density >= lb & knn_density <= ub)
# })

## Do stratified sampling 
# m <- 500
# ns <- ceiling((strata_sizes/sum(strata_sizes))*m)+1L
# strata <- lapply(seq(length(knn_levels)-1L), function(i){
# 	lb <- knn_levels[i]
# 	ub <- knn_levels[i+1L]
# 	idx <- which(knn_density >= lb & knn_density <= ub)
# 	if (length(idx) == 0){ return(NULL) }
# 	idx[landmark::landmarks_maxmin(X[idx,,drop=FALSE], num = min(c(length(idx), ns[i])))]
# })
# plot(X[unlist(strata),1:2])


	# density_levels <- seq(min(f), max(f), length.out = n.strata)
	# strata_sizes <- sapply(seq(n.strata-1L), function(i){
	# 	lb <- density_levels[i]
	# 	ub <- density_levels[i+1L]
	# 	sum(f >= lb & f <= ub)
	# })
	# ns <- ceiling((strata_sizes/sum(strata_sizes))*m)+1L
	# strata <- lapply(seq(length(density_levels)-1L), function(i){
	# 	lb <- density_levels[i]
	# 	ub <- density_levels[i+1L]
	# 	idx <- which(f >= lb & f <= ub)
	# 	if (length(idx) == 0){ return(NULL) }
	# 	idx[landmark::landmarks_maxmin(x[idx,,drop=FALSE], num = min(c(length(idx), ns[i])))]
	# })
	# return(unlist(strata))
stratified_sample <- function(x, m, f, n.strata=25L){
	strata <- hist(x = f, breaks = seq(min(f), max(f), length.out = n.strata+1L), plot = FALSE)
	ns <- table(sample(x = seq(n.strata), size = m, replace = TRUE, prob = strata$counts/length(f)))
	strata_idx <- lapply(names(ns), function(s){
		bounds <- c(lb=strata$breaks[as.integer(s)], ub=strata$breaks[as.integer(s)+1L])
		idx <- which(f >= bounds[1] & f <= bounds[2])
		if (length(idx) == 0){ return(NULL) }
		idx[landmark::landmarks_maxmin(x[idx,,drop=FALSE], num = ns[s])]
	})
	return(unlist(strata_idx))
}

# saveRDS(X[unlist(strata),], "optical_500.rds")
# readr::write_csv(as.data.frame(X[unlist(strata),]), path = "optimal_500.csv", col_names = FALSE)
# points(X[knn_density < 0.0009165355,1:2], col = "purple", pch =20)
# image(matrix(Y[which.max(X[,2]),], nrow = 3), col = gray.colors(9, start = 0, end = 1))
```

```{r klein}
library("dart")
#X <- R.matlab::readMat("~/Downloads/nk")$n50000Dct
X <- R.matlab::readMat("~/Downloads/n50000Dct.mat")$n50000Dct
# X <- R.matlab::readMat("~/Downloads/nk15c30Dct.mat")$nk15c30Dct

## Density estimate
k <- 300L
Vd <- function(d){ (pi^(d/2))/(gamma(d/2.0 + 1)) }
knn_density <- local({
	x_knn <- RANN::nn2(X, k = k)
	(k/nrow(X))*(1/(Vd(ncol(X))*x_knn$nn.dists[,k]))
})

## Parameters
n <- 500 
max_diam <- 1.2
xbin <- 8L
ybin <- 8L

## Stratified maxmin sampling of X
sample_idx <- stratified_sample(X, m = n, f = knn_density, n.strata = 25)
x <- X[sample_idx,,drop=FALSE]
f <- normalize(max(knn_density[sample_idx]) - knn_density[sample_idx])
plot(x, pch = 20, col = bin_col(x = f, col_pal = rainbow(100, start = 0, end = 4/6)))
# sample_idx <- sample(1:nrow(X), size = 500)
dx <- geodesic_dist(x, k = 15L)


## Get line arrangement + dual graph 
# ro <- bigraded_betti(x = x, f = f, H = 1L, xbin = xbin, ybin = ybin, max_dist = max_diam, 
# 										 save.path = "~/pc_f.txt")
sr <- sparse_rips(dx, alpha = max_diam)
S <- sparsify_rips(sr$graph, p = sr$permutation, w = sr$radii, epsilon = 0.1, 
									 alpha = sr$alpha, filtered = TRUE, dim = 2)
# S <- sparse_rips_filtration(x, epsilon = 0.1, dim = 2L)

s <- S$simplices
f1 <- S$grading
f2 <- sapply(s, function(simplex){ max(knn_density[sample_idx[simplex]]) })
f1 <- normalize(f1)
f2 <- normalize(f2)
ro <- bigraded_betti2(x = s, f1 = f1, f2 = f2, H = 1L, xbin = xbin, ybin = ybin, save.path = "~/pc_f.txt")


LA <- dual_line_arrangement(x = ro)
singularities <- sapply(LA, sf::st_area) <= .Machine$double.eps
LA <- sf::st_geometrycollection(LA[!singularities])

dg <- dual_graph(LA)
centroids <- do.call(rbind, lapply(LA, sf::st_centroid))

plot(LA, col = "lightgray", asp = 1)
for (i in 1:nrow(dg)){ 
	segments(x0 = centroids[dg[i,1],1], y0 = centroids[dg[i,1],2], 
					 x1 = centroids[dg[i,2],1], y1 = centroids[dg[i,2],2], 
					 col = rainbow(nrow(dg))[i], lwd = 0.75) 
}


## Plot projection of data 
plot(x, pch = 20, col = adjustcolor("black", alpha.f = 0.50))
plot_hilbert(ro, highlight = 1)
plot(LA, col = "lightgray")
points(centroids, col = "red", pch = 20, cex = 0.75)
points(centroids, col = "black", pch = 21, cex = 0.75)

dx <- parallelDist::parallelDist(x)
R <- simplextree::rips(dx, dim = 2, eps = max_diam, filtered = FALSE)
# S_enc <- straverse(level_order(R), function(simplex){ 
# 	rankr::rank_comb(matrix(simplex), R$n_simplices[1]) 
# })
# S_dim <- rep(seq(R$dimension+1L), times=R$n_simplices)

## recover rips weights + density weight for each simplex
## TODO: current bottleneck
# S <- R$simplices
# dist_f <- R$weights
FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), dx[rankr::rank_comb(t(R$edges), n = R$n_simplices[1])])
S <- FI$simplices 
dist_f <- FI$grading
dens_f <- sapply(S, function(x){ max(f[x]) })
f_simp <- unlist(simplex_to_str(S))

## For each vertex in the dual graph, use point-line duality to get filtration 
fibers <- cbind(m=centroids[,1], b=-centroids[,2]) ## use duality here
minimal_bigrades_t <- t(structure(cbind(dens_f, dist_f), dimnames = list(f_simp, NULL)))

## project onto each of the fibers
# fibered_filtrations <- lapply(seq(nrow(fibers)), function(fi){
# 	print(fi)
# 	fiber <- fibers[fi,]
# 	proj_pts <- dart:::push_map(minimal_bigrades_t, m = fiber[1], b = fiber[2])
# 	# proj_pts <- dart:::proj_L(minimal_bigrades, m = fiber[1], b = fiber[2])
# 	# dist_to_src <- as.vector(proxy::dist(matrix(c(0, fiber[2]), ncol = 2), y = proj_pts))
# 	# f_simp[order(proj_pts[,3])]
# 	order(proj_pts[,3])
# })

## Get spearman distance weights on dual graph edges
S_dist <- apply(dg, 1, function(e){
	bi0 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[1],1], b = fibers[e[1],2])
	bi1 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[2],1], b = fibers[e[2],2])
  spearman_dist(order(bi0[,3]), order(bi1[,3]))
})
names(S_dist) <- apply(dg, 1, simplex_to_str)

K_dist <- apply(dg, 1, function(e){
	bi0 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[1],1], b = fibers[e[1],2])
	bi1 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[2],1], b = fibers[e[2],2])
  kendall_dist(order(bi0[,3]), order(bi1[,3]))
})

## Get starting point
e0 <- which(sapply(LA, function(el) { 
	any(apply(el[[1]], 1, function(pt){ sum(abs(pt - sf::st_bbox(LA)[c(1,4)])) < .Machine$double.eps }))
}))[1]

## Build the MST 2-approximation
G1 <- igraph::graph.empty(n = nrow(centroids), directed = FALSE)
for (i in seq(nrow(dg))){
	G1 <- igraph::add_edges(G1, dg[i,], weight = K_dist[i])
}
mst_path <- igraph::mst(G1, weights = igraph::E(G1)$weight)
el <- igraph::as_edgelist(mst_path)
G2 <- igraph::graph_from_edgelist(rbind(el, el[,2:1]), directed = TRUE)
vertex_path <- as.vector(unlist(igraph::dfs(G2, root = e0, neimode = "out")$order))

## Deduce the Eulerian path from the DFS vertex order
path <- cbind(NA, vertex_path[1])
visited <- c(vertex_path[1])
for (vi in seq(2, length(vertex_path))){
	nv <- vertex_path[vi]
	neighbors <- as.vector(igraph::adjacent_vertices(G2, nv)[[1]])
	visited_neighbors <- neighbors[neighbors %in% visited]
	if (length(visited_neighbors) == 1){
		path <- rbind(path, c(visited_neighbors, nv))
		visited <- c(visited, nv)
	} else {
		neighbor_dist <- apply(cbind(nv, visited_neighbors), 1, function(x){
			K_dist[simplex_to_str(sort(x))]
		})
		nearest_neighbor <- visited_neighbors[which.min(neighbor_dist)]
		path <- rbind(path, c(nearest_neighbor, nv))
		visited <- c(visited, nv)
	}
}

## MST 
plot(LA, col = "lightgray")
for (i in 1:nrow(el)){ 
	segments(x0 = centroids[el[i,1],1], y0 = centroids[el[i,1],2], 
					 x1 = centroids[el[i,2],1], y1 = centroids[el[i,2],2], 
					 col = rainbow(nrow(el))[i], lwd = 0.75) 
}
# fiber_path <- lapply(as.vector(arrangement_path), function(fi){
# 	fiber <- fibers[fi,]
# 	proj_pts <- proj_L(minimal_bigrades, m = fiber[1], b = fiber[2])
# 	dist_to_src <- as.vector(proxy::dist(matrix(c(0, fiber[2]), ncol = 2), y = proj_pts))
# 	rownames(minimal_bigrades[order(dist_to_src),])
# })


## Hilbert function
plot_hilbert(ro, betti = 1, highlight = 5, show_grid = TRUE)

## Line arrangement
plot(LA, col = "lightgray", lwd = 0.5)
for (i in 1:nrow(dg)){ 
	segments(x0 = centroids[dg[i,1],1], y0 = centroids[dg[i,1],2], 
					 x1 = centroids[dg[i,2],1], y1 = centroids[dg[i,2],2], 
					 col = "blue", lwd = 0.5, lty = 3) 
}
for (i in seq(length(vertex_path)-1)){
	# arrows(x0 = centroids[i,1], y0 = centroids[i,2], 
	# 			 x1 = centroids[i+1,1], y1 = centroids[i+1,2], 
	# 			 col = rainbow(length(vertex_path))[i], lwd = 0.75, length = 0.05)
	diagram::curvedarrow(centroids[i,], centroids[i+1,], lwd = 0.5, arr.pos = 1, curve = -0.10, 
											 arr.type = "simple", arr.length = 0.1)
}
#plotrix::draw.arc(centroids[1,1], centroids[1,2])
# diagram::curvedarrow(centroids[1,], centroids[2,])
```

```{r moves reduction}
## Deduce form the path which decompositions to save in memory
needs_saved <- !sapply(2:nrow(path), function(i){ path[i,1] == path[i-1,2] })
needs_saved <- path[c(FALSE, needs_saved),1]

##  Precompute the entire sequence of moves
saved <- list()
M1 <- structure(list(matrix(0, ncol = 0, nrow = 2)), names = e0)
M2 <- structure(list(matrix(0, ncol = 0, nrow = 2)), names = e0)
bv <- as.character(e0) ## base vertex
di <- unname(sapply(str_to_simplex(colnames(minimal_bigrades_t)), length)-1L)
s1 <- which(di==1)
s2 <- which(di==2)
bigrades <- dart:::push_map(minimal_bigrades_t, m = fibers[e0,1], b = fibers[e0,2])
p1 <- order(bigrades[s1,3])
p2 <- order(bigrades[s2,3])
for (i in 2:nrow(path)){
	v <- path[i,2]
	bigrades <- dart:::push_map(minimal_bigrades_t, m = fibers[v,1], b = fibers[v,2])
	q1 <- order(bigrades[s1,3])
	q2 <- order(bigrades[s2,3])
	S1 <- greedy_min_cross2(p1, q1, strategy = "pairwise")
	S2 <- greedy_min_cross2(p2, q2, strategy = "pairwise")
	M1[[bv]] <- cbind(M1[[bv]], S1)
	M2[[bv]] <- cbind(M2[[bv]], S2)
	if (v %in% needs_saved){
		print(sprintf("Saving: %d", v))
		saved[[as.character(v)]] <- list(q1, q2)
	}
	if (i != nrow(path)){
		if (path[i,2] != path[i+1,1]){
			print("changing base vertex")
			bv <- as.character(path[i+1,1]) ## change base vertex
			p1 <- saved[[as.character(path[i+1,1])]][[1]]
			p2 <- saved[[as.character(path[i+1,1])]][[2]]
		} else {
			p1 <- q1 
			p2 <- q2
		}
	}
}

# st <- simplextree::simplex_tree(str_to_simplex(fibered_filtrations[[as.integer(v)]]))
# FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), dx[rankr::rank_comb(t(R$edges), n = R$n_simplices[1])])
# dart:::boundary_matrix_fi()

## Apply the clearing optimization
# {
# 	pivots <- apply(RV$R[[2]], 2, dart:::low_entry)
# 	r2_cols <- which(pivots != 0)
# 	r1_cols <- pivots[r2_cols]
# 	# R1 columns already cleared
# 	# all(RV$R[[1]][,r1_cols] == 0)
# 	RV$V[[1]][,r1_cols] <- RV$R[[2]][,r2_cols]
# }
slex_order <- match(
	as.list(level_order(R)), 
	lapply(str_to_simplex(colnames(minimal_bigrades_t)), as.integer)
)
moves_nc <- 0L
## Perform the sequence of moves
for (v in names(M1)){
	vi <- as.integer(v)
	P <- dart:::push_map(x = minimal_bigrades_t, m = fibers[vi,1], b = fibers[vi,2])
	FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), P[slex_order,3])
	
	D1_psp <- dart::psp_matrix(x = dart:::boundary_matrix_fi(filtration = FI$as_XPtr(), k = 1))
	D2_psp <- dart::psp_matrix(x = dart:::boundary_matrix_fi(filtration = FI$as_XPtr(), k = 2))
	V1_psp <- dart::psp_matrix(x = Matrix::Diagonal(D1_psp$matrix$n_cols))
	V2_psp <- dart::psp_matrix(x = Matrix::Diagonal(D2_psp$matrix$n_cols))
	discard <- dart:::reduce_local_pspbool(
		D1_ptr = D1_psp$matrix$as_XPtr(), V1_ptr = V1_psp$matrix$as_XPtr(), 
		D2_ptr = D2_psp$matrix$as_XPtr(), V2_ptr = V2_psp$matrix$as_XPtr(),
		clearing = TRUE
	)
	# RV <- dart::reduce(D, output = "RV", validate = FALSE)
	
	## TODO: make faster when this becomes bottleneck
	D1_psp$matrix$clean(0)
	D2_psp$matrix$clean(0)
	V1_psp$matrix$clean(0)
	V2_psp$matrix$clean(0)
	RV <- list(
		R = list(as(D1_psp, "sparseMatrix"), as(D2_psp, "sparseMatrix")), 
		V = list(as(V1_psp, "sparseMatrix"), as(V2_psp, "sparseMatrix"))
	)	
	RV$R[[3]] <- Matrix::Matrix(matrix(0, ncol = 0, nrow = R$n_simplices[3]), sparse = TRUE)
	RV$V[[3]] <- Matrix::Matrix(matrix(0, ncol = 0, nrow = 0), sparse = TRUE)
	
	moves_nc2 <- vector("integer", length = ncol(M2[[v]]))
	cc <- 0L
	execute_schedule(R = RV$R[2:3], V = RV$V[2:3], S = M2[[v]], f = function(fbm_decomp){
		cc <<- cc + 1L
		moves_nc2[cc] <<- fbm_decomp$m
		print(cc)
	})

	moves_nc1 <- vector("integer", length = ncol(M1[[v]]))
	cc <- 0L
	execute_schedule(R = RV$R[1:2], V = RV$V[1:2], S = M1[[v]], f = function(fbm_decomp){
		cc <<- cc + 1L
		moves_nc1[cc] <<- fbm_decomp$m
		print(cc)
	})
	moves_nc <- moves_nc <- sum(moves_nc1) + sum(moves_nc2)
	print(v)
}
	# RV$R[[3]] <- D$matrix[[3]]
	# RV$V[[3]] <- Matrix::Matrix(matrix(0, ncol = 0, nrow = 0), sparse = TRUE)
	# 
	# ## TODO: remove this once permutable sp matrices are supported
	# RV$R[[1]] <- as(RV$R[[1]], "sparseMatrix")
	# RV$R[[2]] <- as(RV$R[[2]], "sparseMatrix")
	# RV$V[[1]] <- as(RV$V[[1]], "sparseMatrix")
	# RV$V[[2]] <- as(RV$V[[2]], "sparseMatrix")
	# 	
	# ncol_2 <- vector("integer", length = ncol(M2[[v]]))
	# cc <- 0L
	# execute_schedule(R = RV$R[2:3], V = RV$V[2:3], S = M2[[v]], f = function(fbm_decomp){ 
	# 	cc <<- cc + 1L
	# 	ncol_2[cc] <<- fbm_decomp$m 
	# 	print(cc)
	# })
	# 
	# ncol_1 <- vector("integer", length = ncol(M1[[v]]))
	# cc <- 0L
	# execute_schedule(R = RV$R[1:2], V = RV$V[1:2], S = M1[[v]], f = function(fbm_decomp){ 
	# 	cc <<- cc + 1L
	# 	ncol_1[cc] <<- fbm_decomp$m 
	# 	print(cc)
	# })

```

```{r naive reduction}
## Use naive reduction 
st <- simplextree::simplex_tree(str_to_simplex(colnames(minimal_bigrades_t)))
ncol_reduction <- vector(mode = "integer", length = nrow(centroids))
for (v in vertex_path){
	bigrades <- dart:::push_map(minimal_bigrades_t, m = fibers[v,1], b = fibers[v,2])
	FI <- new(dart:::ImplicitFiltration, st$as_XPtr(), bigrades[,3])
	D <- dart:::boundary_matrix_fi_full(filtration = FI$as_XPtr())
	# D <- boundary_matrix(str_to_simplex(fibered_filtrations[[as.integer(v)]]))
	# RV <- pbgrad::reduce(D$matrix, output = "RV")
	# RV <- pbgrad::reduce(D, output = "RV")
	# RV <- dart::reduce(D)
	D_psp <- dart::psp_matrix(x = D)
	V_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D)))
	nc <- dart:::reduce_pspbool(D_psp$matrix$as_XPtr(), V_psp$matrix$as_XPtr())
	ncol_reduction[match(v, vertex_path)] <- nc
	print(match(v, vertex_path))
}
sum(ncol_reduction)
```

```{r trash}
# # 1348 = 658 + 690 
# sum(ncol_1) + sum(ncol_2)
# 
# sum(ncol_reduction)
# ncol_reduction[1] + sum(ncol_1) + sum(ncol_2)
# 
# ## Use vineyards 
# dart::vineyards_schedule
# 
# 
# # dart:::move_schedule_local(
# # 	r1 = RV$R[[1]]$matrix$as_XPtr(), 
# # 	v1 = RV$V[[1]]$matrix$as_XPtr(), 
# # 	r2 = RV$R[[2]]$matrix$as_XPtr(), 
# # 	v2 = RV$V[[2]]$matrix$as_XPtr(), 
# # 	schedule = matrix(c(3, 8), nrow = 2)
# # )
# lapply(seq(nrow(fibers)), function(fi){
# 	fiber <- fibers[fi,]
# 	proj_pts <- dart:::push_map(t(minimal_bigrades), m = fiber[1], b = fiber[2])
# 	# proj_pts <- dart:::proj_L(minimal_bigrades, m = fiber[1], b = fiber[2])
# 	# dist_to_src <- as.vector(proxy::dist(matrix(c(0, fiber[2]), ncol = 2), y = proj_pts))
# 	f_simp[order(proj_pts[,3])]
# })
# 
# 
# 
# 
# 
# ## Reduce the first filtration
# dart::reduce()
# 

```

Vineyards computation along path
```{r vineyards}
library(simplextree)
## Deduce form the path which decompositions to save in memory
needs_saved <- !sapply(2:nrow(path), function(i){ path[i,1] == path[i-1,2] })
needs_saved <- path[c(FALSE, needs_saved),1]

## Plot path  
plot(LA, col = "lightgray")
for (i in 1:nrow(el)){ 
	segments(x0 = centroids[el[i,1],1], y0 = centroids[el[i,1],2], 
					 x1 = centroids[el[i,2],1], y1 = centroids[el[i,2],2], 
					 col = rainbow(nrow(el))[i], lwd = 0.75) 
}

slex_order <- match(
	as.list(level_order(R)), 
	lapply(str_to_simplex(colnames(minimal_bigrades_t)), as.integer)
)
saved <- list()
M <- structure(list(matrix(0, ncol = 0, nrow = 2)), names = e0)
bv <- as.character(e0) ## base vertex
P <- dart:::push_map(minimal_bigrades_t, m = fibers[e0,1], b = fibers[e0,2])
p <- order(P[,3])

## Cost for each vineyard update
# status_costs <- c(2,2,0,1,2,0,2,0,1)
# vineyard_nc <- 0L
# save_cost <- function(status){
# 	vineyard_nc <<- vineyard_nc + status_costs[status]
# }
vineyard_nc <- 0L
for (i in 2:nrow(path)){
	v <- path[i,2]
	Q <- dart:::push_map(minimal_bigrades_t, m = fibers[v,1], b = fibers[v,2])
	S <- vineyards_schedule(simplices[p], simplices[order(Q[,3])])
	schedule <- pmin(S$schedule[1,], S$schedule[2,])
	# M[[bv]] <- cbind(M[[bv]], S$schedule)
	FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), Q[slex_order,3])
	D <- dart:::boundary_matrix_fi_full(filtration = FI$as_XPtr())
	D_psp <- dart::psp_matrix(x = D)
	V_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D)))
	vineyard_nc <- vineyard_nc + dart:::simulate_vineyard_pspbool(
		R_ptr = D_psp$matrix$as_XPtr(), V_ptr = V_psp$matrix$as_XPtr(), 
		schedule = schedule - 1L)
	print(i)
	if (v %in% needs_saved){
		print(sprintf("Saving: %d", v))
		saved[[as.character(v)]] <- fibers[v,]
	}
	if (i != nrow(path)){
		if (path[i,2] != path[i+1,1]){
			print("changing base vertex")
			bv <- as.character(path[i+1,1]) ## change base vertex
			c_fiber <- saved[[as.character(path[i+1,1])]]
			p <- order(dart:::push_map(minimal_bigrades_t, m = c_fiber[1], b = c_fiber[2])[,3])
		} else {
			p <- q
		}
	}
}
# saveRDS(list(dataset="n50000Dct", n=n, k=k, diam=max_diam, xbin=xbin, ybin=ybin, H=1L, schedule=M), 
# 				file = "raw/vineyards_schedule.rds")
		
```

"with resets"
```{r}

R <- pbgrad::
```

tests

```{r all the tests}
library("dart")
# X <- R.matlab::readMat("~/Downloads/n50000Dct.mat")$n50000Dct
X <- R.matlab::readMat("~/Downloads/nk15c30Dct.mat")$nk15c30Dct
	
n <- 375 
max_diam <- 0.7

## Density estimate
# k <- 300L
k <- 15L
Vd <- function(d){ (pi^(d/2))/(gamma(d/2.0 + 1)) }
knn_density <- local({
	x_knn <- RANN::nn2(X, k = k)
	(k/nrow(X))*(1/(Vd(ncol(X))*x_knn$nn.dists[,k]))
})

## Stratified maxmin sampling of X
sample_idx <- stratified_sample(X, m = n, f = knn_density)
x <- X[sample_idx,,drop=FALSE]
f <- normalize(max(knn_density[sample_idx]) - knn_density[sample_idx])

## Parameters
bin_sizes <- seq(8, 24, by=4)
reduction_total <- vector("integer", length = length(bin_sizes))
for (b in bin_sizes){
	xbin <- b; ybin <- b
	
	## Get line arrangement + dual graph 
	ro <- bigraded_betti(
		x = x, f = f, H = 1L, xbin = xbin, ybin = ybin, max_dist = max_diam, 
		save.path = "~/pc_f.txt"
	)
	
	## Line arrangement + dual graph
	LA <- dual_line_arrangement(x = ro)
	singularities <- sapply(LA, sf::st_area) <= .Machine$double.eps
	LA <- sf::st_geometrycollection(LA[!singularities])
	dg <- dual_graph(LA)
	centroids <- do.call(rbind, lapply(LA, sf::st_centroid))

	## Complex + bifiltration values 
	dx <- parallelDist::parallelDist(x)
	R <- simplextree::rips(dx, dim = 2, eps = max_diam, filtered = FALSE)
	FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), 
						dx[rankr::rank_comb(t(R$edges), n = R$n_simplices[1])])
	simplices <- FI$simplices 
	dist_f <- FI$grading
	dens_f <- sapply(simplices, function(x){ max(f[x]) })

	## Fibers + bigrades
	fibers <- cbind(m=centroids[,1], b=-centroids[,2]) ## use duality here
	minimal_bigrades_t <- t(structure(
		cbind(dens_f, dist_f), 
		dimnames = list(unlist(simplex_to_str(simplices)), NULL))
	)

	## Vertex path in dual graph 
	e0 <- which(sapply(LA, function(el) { 
		any(apply(el[[1]], 1, function(pt){ 
			sum(abs(pt - sf::st_bbox(LA)[c(1,4)])) < .Machine$double.eps }))
		})
	)[1]
	G2 <- local({
		S_dist <- apply(dg, 1, function(e){
			bi0 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[1],1], b = fibers[e[1],2])
			bi1 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[2],1], b = fibers[e[2],2])
		  spearman_dist(order(bi0[,3]), order(bi1[,3]))
		})
	
		## Build the MST 2-approximation
		G1 <- igraph::graph.empty(n = nrow(centroids), directed = FALSE)
		for (i in seq(nrow(dg))){
			G1 <- igraph::add_edges(G1, dg[i,], weight = S_dist[i])
		}
		mst_path <- igraph::mst(G1, weights = igraph::E(G1)$weight)
		el <- igraph::as_edgelist(mst_path)
		igraph::graph_from_edgelist(rbind(el, el[,2:1]), directed = TRUE)
	})
	vertex_path <- as.vector(unlist(igraph::dfs(G2, root = e0, neimode = "out")$order))
	
	## Eulerian path from the vertex order
	path <- cbind(NA, vertex_path[1])
	visited <- c(vertex_path[1])
	for (vi in seq(2, length(vertex_path))){
		nv <- vertex_path[vi]
		neighbors <- as.vector(igraph::adjacent_vertices(G2, nv)[[1]])
		visited_neighbors <- neighbors[neighbors %in% visited]
		if (length(visited_neighbors) == 1){
			path <- rbind(path, c(visited_neighbors, nv))
			visited <- c(visited, nv)
		} else {
			neighbor_dist <- apply(cbind(nv, visited_neighbors), 1, function(x){
				K_dist[simplex_to_str(sort(x))]
			})
			nearest_neighbor <- visited_neighbors[which.min(neighbor_dist)]
			path <- rbind(path, c(nearest_neighbor, nv))
			visited <- c(visited, nv)
		}
	}
	
	## Naive reduction 
	ncol_reduction <- vector(mode = "integer", length = nrow(centroids))
	for (v in vertex_path){
		bigrades <- dart:::push_map(minimal_bigrades_t, m = fibers[v,1], b = fibers[v,2])
		FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), bigrades[,3])
		D <- dart:::boundary_matrix_fi_full(filtration = FI$as_XPtr())
		D_psp <- dart::psp_matrix(x = D)
		V_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D)))
		nc <- dart:::reduce_pspbool(D_psp$matrix$as_XPtr(), V_psp$matrix$as_XPtr())
		
		# D1 <- dart:::boundary_matrix_fi(filtration = FI$as_XPtr(), k = 1L)
		# D2 <- dart:::boundary_matrix_fi(filtration = FI$as_XPtr(), k = 2L)
		# D1_psp <- dart::psp_matrix(x = D1)
		# D2_psp <- dart::psp_matrix(x = D2)
		# V1_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D1)))
		# V2_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D2)))
		# nc <- dart:::reduce_local_pspbool(
		# 	D1_ptr = D1_psp$matrix$as_XPtr(), V1_ptr = V1_psp$matrix$as_XPtr(), 
		# 	D2_ptr = D2_psp$matrix$as_XPtr(), V2_ptr = V2_psp$matrix$as_XPtr(),
		# 	clearing = TRUE)
		
		ncol_reduction[match(v, vertex_path)] <- nc
	}
	
	## Save progress
	reduction_total[match(b, bin_sizes)] <- sum(ncol_reduction)
	print(sum(ncol_reduction))
}



# # f <- normalize(knn_density[sample_idx])
# plot(x, pch = 20, col = bin_col(x = f, col_pal = rainbow(100, start = 0, end = 4/6)))
# # sample_idx <- sample(1:nrow(X), size = 500)
# 
# ## Get line arrangement + dual graph 
# ro <- bigraded_betti(x = x, f = f, H = 1L, xbin = xbin, ybin = ybin, max_dist = max_diam, 
# 										 save.path = "~/pc_f.txt")
# 
# 
# LA <- dual_line_arrangement(x = ro)
# singularities <- sapply(LA, sf::st_area) <= .Machine$double.eps
# LA <- sf::st_geometrycollection(LA[!singularities])
```


```{r vineyards tests}
library(simplextree)
library(dart)
library(Matrix)

## Parameters
set.seed(1234)
bin_sizes <- seq(8, 24, by=4)
vineyards_total <- vector("integer", length = length(bin_sizes))
n <- 375 
max_diam <- 0.70

sample_idx <- stratified_sample(X, m = n, f = knn_density)
x <- X[sample_idx,,drop=FALSE]
f <- normalize(max(knn_density[sample_idx]) - knn_density[sample_idx])


for (b in bin_sizes){
	xbin <- b; ybin <- b
	
	## Get line arrangement + dual graph 
	ro <- bigraded_betti(
		x = x, f = f, H = 1L, xbin = xbin, ybin = ybin, max_dist = max_diam, 
		save.path = "~/pc_f.txt"
	)
	
	## Line arrangement + dual graph
	LA <- dual_line_arrangement(x = ro)
	singularities <- sapply(LA, sf::st_area) <= .Machine$double.eps
	LA <- sf::st_geometrycollection(LA[!singularities])
	dg <- dual_graph(LA)
	centroids <- do.call(rbind, lapply(LA, sf::st_centroid))

	## Complex + bifiltration values 
	dx <- parallelDist::parallelDist(x)
	R <- simplextree::rips(dx, dim = 2, eps = max_diam, filtered = FALSE)
	FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), 
						dx[rankr::rank_comb(t(R$edges), n = R$n_simplices[1])])
	simplices <- FI$simplices 
	dist_f <- FI$grading
	dens_f <- sapply(simplices, function(x){ max(f[x]) })

	## Fibers + bigrades
	fibers <- cbind(m=centroids[,1], b=-centroids[,2]) ## use duality here
	minimal_bigrades_t <- t(structure(
		cbind(dens_f, dist_f), 
		dimnames = list(unlist(simplex_to_str(simplices)), NULL))
	)

	## Vertex path in dual graph 
	e0 <- which(sapply(LA, function(el) { 
		any(apply(el[[1]], 1, function(pt){ 
			sum(abs(pt - sf::st_bbox(LA)[c(1,4)])) < .Machine$double.eps }))
		})
	)[1]
	G2 <- local({
		S_dist <- apply(dg, 1, function(e){
			bi0 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[1],1], b = fibers[e[1],2])
			bi1 <- dart:::push_map(minimal_bigrades_t, m = fibers[e[2],1], b = fibers[e[2],2])
		  spearman_dist(order(bi0[,3]), order(bi1[,3]))
		})
	
		## Build the MST 2-approximation
		G1 <- igraph::graph.empty(n = nrow(centroids), directed = FALSE)
		for (i in seq(nrow(dg))){
			G1 <- igraph::add_edges(G1, dg[i,], weight = S_dist[i])
		}
		mst_path <- igraph::mst(G1, weights = igraph::E(G1)$weight)
		el <- igraph::as_edgelist(mst_path)
		igraph::graph_from_edgelist(rbind(el, el[,2:1]), directed = TRUE)
	})
	vertex_path <- as.vector(unlist(igraph::dfs(G2, root = e0, neimode = "out")$order))
	
	## Eulerian path from the vertex order
	path <- cbind(NA, vertex_path[1])
	visited <- c(vertex_path[1])
	for (vi in seq(2, length(vertex_path))){
		nv <- vertex_path[vi]
		neighbors <- as.vector(igraph::adjacent_vertices(G2, nv)[[1]])
		visited_neighbors <- neighbors[neighbors %in% visited]
		if (length(visited_neighbors) == 1){
			path <- rbind(path, c(visited_neighbors, nv))
			visited <- c(visited, nv)
		} else {
			neighbor_dist <- apply(cbind(nv, visited_neighbors), 1, function(x){
				K_dist[simplex_to_str(sort(x))]
			})
			nearest_neighbor <- visited_neighbors[which.min(neighbor_dist)]
			path <- rbind(path, c(nearest_neighbor, nv))
			visited <- c(visited, nv)
		}
	}

	## Deduce form the path which decompositions to save in memory
	needs_saved <- !sapply(2:nrow(path), function(i){ path[i,1] == path[i-1,2] })
	needs_saved <- path[c(FALSE, needs_saved),1]
	saved <- list()
	bv <- as.character(e0) ## base vertex
	P <- dart:::push_map(minimal_bigrades_t, m = fibers[e0,1], b = fibers[e0,2])
	p <- order(P[,3])

	print("vertex path: ")
	print(vertex_path)
	
	FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), p)
	D <- dart:::boundary_matrix_fi_full(filtration = FI$as_XPtr())
	D_psp <- dart::psp_matrix(x = D)
	V_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D)))
	dart:::reduce_pspbool(D_psp$matrix$as_XPtr(), V_psp$matrix$as_XPtr(), show_progress = TRUE)
	
	## Do the vineyards updates
	vineyard_nc <- 0L
	for (i in 2:nrow(path)){
		v <- path[i,2]
		Q <- dart:::push_map(minimal_bigrades_t, m = fibers[v,1], b = fibers[v,2])
		q <- order(Q[,3])
		schedule <- local({
			S <- vineyards_schedule(simplices[p], simplices[q])
			pmin(S$schedule[1,], S$schedule[2,])
		})

		vineyard_nc <- vineyard_nc + dart:::simulate_vineyard_pspbool(
			R_ptr = D_psp$matrix$as_XPtr(), V_ptr = V_psp$matrix$as_XPtr(), 
			schedule = schedule - 1L)
		print(i)
		if (v %in% needs_saved){
			print(sprintf("Saving: %d", v))
			saved[[as.character(v)]] <- fibers[v,]
		}
		if (i != nrow(path)){
			if (path[i,2] != path[i+1,1]){
				print("changing base vertex")
				bv <- as.character(path[i+1,1]) ## change base vertex
				c_fiber <- saved[[as.character(path[i+1,1])]]
				P <- dart:::push_map(minimal_bigrades_t, m = c_fiber[1], b = c_fiber[2])
				p <- order(P[,3])
				FI <- new(dart:::ImplicitFiltration, R$as_XPtr(), P[,3])
				D <- dart:::boundary_matrix_fi_full(filtration = FI$as_XPtr())
				D_psp <- dart::psp_matrix(x = D)
				V_psp <- dart::psp_matrix(x = Matrix::Diagonal(ncol(D)))
				dart:::reduce_pspbool(D_psp$matrix$as_XPtr(), V_psp$matrix$as_XPtr(), show_progress = TRUE)
			} else {
				p <- q
			}
		}
	}
	
	## Save progress
	vineyards_total[match(b, bin_sizes)] <- sum(vineyard_nc)
	print(vineyard_nc)
}
```

```{r}
lm_idx <- landmark::landmarks_maxmin(X, num = 150, seed_index = which.min(d_left))
eps <- max(dbscan:::prims(dist(X[lm_idx,]), n = length(lm_idx))[,3])
R <- simplextree::rips(dist(X[lm_idx,]), eps = eps, dim = 2)
plot(R, coords = X[lm_idx,1:2])
```

